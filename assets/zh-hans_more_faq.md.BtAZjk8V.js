import{_ as o,c as a,o as s,ag as t}from"./chunks/framework.CkHWihve.js";const p=JSON.parse('{"title":"FAQ","description":"","frontmatter":{},"headers":[],"relativePath":"zh-hans/more/faq.md","filePath":"zh-hans/more/faq.md","lastUpdated":1755823056000}'),r={name:"zh-hans/more/faq.md"};function d(c,e,i,n,l,h){return s(),a("div",null,e[0]||(e[0]=[t('<h1 id="faq" tabindex="-1">FAQ <a class="header-anchor" href="#faq" aria-label="Permalink to &quot;FAQ&quot;">​</a></h1><p>以下是 <code>asdf</code> 相关的一些常见问题。</p><h2 id="支持-wsl1-吗" tabindex="-1">支持 WSL1 吗？ <a class="header-anchor" href="#支持-wsl1-吗" aria-label="Permalink to &quot;支持 WSL1 吗？&quot;">​</a></h2><p>WSL1 (<a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux#WSL_1" target="_blank" rel="noreferrer">Windows Subsystem for Linux 1</a>) 不受官方支持。<code>asdf</code> 的某些方面可能无法正常工作。我们不打算添加对 WSL1 的官方支持。</p><h2 id="支持-wsl2-吗" tabindex="-1">支持 WSL2 吗？ <a class="header-anchor" href="#支持-wsl2-吗" aria-label="Permalink to &quot;支持 WSL2 吗？&quot;">​</a></h2><p>WSL2 (<a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux#WSL_2" target="_blank" rel="noreferrer">Windows Subsystem for Linux 2</a>) 应该作为你选择的 WSL 发行版来使用本设置和依赖说明。</p><p>重要的是，只有当前工作目录是 Unix 驱动器而不是绑定的 Windows 驱动器时，WSL2 <em>才能</em> 正常工作。</p><p>当 Github Actions 上提供主机运行器支持时，我们打算在 WSL2 上运行测试套件。（Github Actions 目前还未提供 WSL2 支持）</p><h2 id="新安装的可执行程序无法运行" tabindex="-1">新安装的可执行程序无法运行？ <a class="header-anchor" href="#新安装的可执行程序无法运行" aria-label="Permalink to &quot;新安装的可执行程序无法运行？&quot;">​</a></h2><blockquote><p>我执行了 <code>npm install -g yarn</code> 命令，但是之后不能运行 <code>yarn</code> 命令。这是为什么？</p></blockquote><p><code>asdf</code> 使用 <a href="https://zh.wikipedia.org/wiki/%E5%9E%AB%E7%89%87_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)" target="_blank" rel="noreferrer">垫片</a> 来管理可执行程序。插件所安装的那些命令会自动创建垫片，而通过 <code>asdf</code> 管理工具安装过的可执行程序则需要通知 <code>asdf</code> 创建垫片的需要。在这个例子中，为 <a href="https://yarnpkg.com/" target="_blank" rel="noreferrer">Yarn</a> 创建一个垫片即可。请查看 <a href="/zh-hans/manage/core.html#reshim"><code>asdf reshim</code> 命令文档</a> 了解更多。</p><h2 id="shell-没有检测到新安装的垫片" tabindex="-1">Shell 没有检测到新安装的垫片？ <a class="header-anchor" href="#shell-没有检测到新安装的垫片" aria-label="Permalink to &quot;Shell 没有检测到新安装的垫片？&quot;">​</a></h2><p>如果 <code>asdf reshim</code> 没有解决你的问题，那么很有可能是在 <code>asdf.sh</code> 或者 <code>asdf.fish</code> 的生效不在你的 Shell 配置文件（<code>.bash_profile</code>、<code>.zshrc</code>、<code>config.fish</code> 等等）的<strong>下方</strong>。这需要你在设置你的 <code>$PATH</code> <strong>之后</strong>和生效你的框架（oh-my-zsh 等等）（如果有的话）<strong>之后</strong>再生效。</p><h2 id="为什么不能在-tool-versions-文件中使用-latest-版本" tabindex="-1">为什么不能在 <code>.tool-versions</code> 文件中使用 <code>latest</code> 版本？ <a class="header-anchor" href="#为什么不能在-tool-versions-文件中使用-latest-版本" aria-label="Permalink to &quot;为什么不能在 `.tool-versions` 文件中使用 `latest` 版本？&quot;">​</a></h2><p>asdf 必须始终使用当前目录的每个工具的精确版本，不允许使用版本范围或特殊值（如 <code>latest</code>）。这确保 asdf 在不同时间和不同机器上以确定性和一致性方式运行。像 <code>latest</code> 这样的特殊版本会随时间变化，并且如果在不同时间运行 <code>asdf install</code>，不同机器上的版本可能会有所不同。因此，它可以在 asdf 命令如 <code>asdf set &lt;tool&gt; latest</code> 中使用，但在 <code>.tool-versions</code> 文件中是被禁止的。</p><p>可将 <code>.tool-versions</code> 文件看成 <code>Gemfile.lock</code> 或者 <code>package-lock.json</code>。该文件包含项目依赖的每个工具的精确版本。</p><p>需要注意的是，<code>system</code> 版本在 <code>.tool-versions</code> 文件中是允许的，且在使用时可能解析为不同版本。这是一个特殊值，可有效禁用指定目录下特定工具的 asdf 功能。</p><p>请查看 <a href="https://github.com/asdf-vm/asdf/issues/1012" target="_blank" rel="noreferrer">https://github.com/asdf-vm/asdf/issues/1012</a> 了解更多。</p><h2 id="为什么不能在-tool-versions-文件中使用版本范围" tabindex="-1">为什么不能在 <code>.tool-versions</code> 文件中使用版本范围？ <a class="header-anchor" href="#为什么不能在-tool-versions-文件中使用版本范围" aria-label="Permalink to &quot;为什么不能在 `.tool-versions` 文件中使用版本范围？&quot;">​</a></h2><p>与上述关于使用 <code>latest</code> 的问题类似。如果指定了版本范围，asdf 将可以自由选择该范围内的任何已安装版本。这可能导致不同机器上出现不同行为，因为它们可能安装了不同版本。asdf 的设计意图是完全确定性的，即相同的 <code>.tool-versions</code> 文件在不同时间和不同计算机上应生成完全相同的环境。</p><p>请查看 <a href="https://github.com/asdf-vm/asdf-nodejs/issues/235#issuecomment-885809776" target="_blank" rel="noreferrer">https://github.com/asdf-vm/asdf-nodejs/issues/235#issuecomment-885809776</a> 了解更多。</p><h2 id="为什么与我使用的插件完全无关的命令会被-asdf-生成垫片" tabindex="-1">为什么与我使用的插件完全无关的命令会被 asdf 生成垫片？ <a class="header-anchor" href="#为什么与我使用的插件完全无关的命令会被-asdf-生成垫片" aria-label="Permalink to &quot;为什么与我使用的插件完全无关的命令会被 asdf 生成垫片？&quot;">​</a></h2><p><strong>asdf 只会为其管理的可执行文件生成垫片</strong>。例如，如果你使用 Ruby 插件，那么你可能会看到 <code>ruby</code> 和 <code>irb</code> 等命令被垫片替换，以及你安装的 Ruby 包中包含的其他可执行文件。</p><p>如果你看到一个意料之外的垫片，很可能是因为你通过 asdf 管理工具安装了一个包，而该包提供了该可执行文件。</p><p>当可执行文件与系统中已存在的可执行文件名称相同，这种情况会令人意外。<a href="https://github.com/asdf-vm/asdf/issues/584" target="_blank" rel="noreferrer">部分用户报告称</a> 某个 Node.JS 包提供了自己的 <code>which</code> 命令版本。这导致 asdf 为其创建了垫片，并替换了操作系统中已存在的 <code>which</code> 命令版本。在这种情况下，最好定位引入可执行文件的包并将其移除。<code>asdf which &lt;command&gt;</code> 命令可帮助你确定问题可执行文件的位置，从而判断是哪一个包添加了可执行文件。</p><p>请查看 <a href="https://github.com/asdf-vm/asdf/issues/584" target="_blank" rel="noreferrer">https://github.com/asdf-vm/asdf/issues/584</a> <a href="https://github.com/asdf-vm/asdf/issues/1653" target="_blank" rel="noreferrer">https://github.com/asdf-vm/asdf/issues/1653</a> 了解更多。</p>',26)]))}const m=o(r,[["render",d]]);export{p as __pageData,m as default};
