import{_ as s,c as e,o as d,ag as o}from"./chunks/framework.CkHWihve.js";const u=JSON.parse('{"title":"升级到 0.16.0","description":"","frontmatter":{},"headers":[],"relativePath":"zh-hans/guide/upgrading-to-v0-16.md","filePath":"zh-hans/guide/upgrading-to-v0-16.md","lastUpdated":1755823056000}'),i={name:"zh-hans/guide/upgrading-to-v0-16.md"};function l(n,a,t,c,p,h){return d(),e("div",null,a[0]||(a[0]=[o('<h1 id="升级到-0-16-0" tabindex="-1">升级到 0.16.0 <a class="header-anchor" href="#升级到-0-16-0" aria-label="Permalink to &quot;升级到 0.16.0&quot;">​</a></h1><p>asdf 0.15.0 版本以及更早版本是用 Bash 编写的，并以一系列 Bash 脚本的形式分发，其中 <code>asdf</code> 函数加载到 shell 中。从 0.16.0 版本开始 asdf 用 Go 语言完全重写了。由于是完全重写，存在一些 <a href="#重大变更">重大变更</a>，现在它是一个二进制文件，而不是一系列脚本。</p><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><p>0.16.0 版本及更高版本的安装比之前的 asdf 版本要简单多了。只需要三个步骤：</p><ul><li>通过 <a href="/zh-hans/guide/getting-started.html#_1-安装-asdf">任意可能的安装方式</a> 下载与操作系统和架构匹配的 <code>asdf</code> 二进制文件。如果使用包管理器，请验证安装的是 0.16.0 版本及更高版本。</li><li>添加 <code>$ASDF_DATA_DIR/shims</code> 变量到 <code>$PATH</code> 路径的最前面。</li><li>可选的是，如果你之前自定义了 asdf 数据目录，请将 <code>ASDF_DATA_DIR</code> 变量设置为包含插件、版本和垫片的旧版本安装目录。</li></ul><p>如果操作系统包管理器已经提供 asdf 0.16.0，那么使用它来安装 asdf 可能是最佳方法。现在，升级 asdf 只能通过操作系统包管理器或手动安装来完成，不再支持自动升级功能。</p><h3 id="不丢失数据的升级" tabindex="-1">不丢失数据的升级 <a class="header-anchor" href="#不丢失数据的升级" aria-label="Permalink to &quot;不丢失数据的升级&quot;">​</a></h3><p>你可以升级到 asdf 的最新版本，而不会丢失现有的安装数据。操作步骤同上。</p><h4 id="_1-下载匹配操作系统和架构的-asdf-二进制文件" tabindex="-1">1. 下载匹配操作系统和架构的 <code>asdf</code> 二进制文件 <a class="header-anchor" href="#_1-下载匹配操作系统和架构的-asdf-二进制文件" aria-label="Permalink to &quot;1. 下载匹配操作系统和架构的 `asdf` 二进制文件&quot;">​</a></h4><p>从 <a href="https://github.com/asdf-vm/asdf/releases" target="_blank" rel="noreferrer">GitHub 发布页面</a> 下载二进制文件，并将其放置在系统路径中的某个目录下。我选择将 asdf 二进制文件放置在 <code>$HOME/bin</code> 目录中，然后将 <code>$HOME/bin</code> 添加在 <code>$PATH</code> 路径最前面：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 在 .zshrc, .bashrc, 等...</span></span>\n<span class="line"><span>export PATH=&quot;$HOME/bin:$PATH&quot;</span></span></code></pre></div><h4 id="_2-设置-asdf-data-dir" tabindex="-1">2. 设置 <code>ASDF_DATA_DIR</code> <a class="header-anchor" href="#_2-设置-asdf-data-dir" aria-label="Permalink to &quot;2. 设置 `ASDF_DATA_DIR`&quot;">​</a></h4><p>运行 <code>asdf info</code> 并复制包含 <code>ASDF_DATA_DIR</code> 变量的行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>\n<span class="line"><span>ASDF_DATA_DIR=&quot;/home/myuser/.asdf&quot;</span></span>\n<span class="line"><span>...</span></span></code></pre></div><p>在 shell RC 配置文件中（比如 Zsh 的 <code>.zshrc</code>，Bash 的 <code>.bashrc</code> 等）末尾添加一行设置 <code>ASDF_DATA_DIR</code> 为相同的值：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ASDF_DATA_DIR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/myuser/.asdf&quot;</span></span></code></pre></div><h4 id="_3-将-asdf-data-dir-shims-加在-path-最前面" tabindex="-1">3. 将 <code>$ASDF_DATA_DIR/shims</code> 加在 <code>$PATH</code> 最前面 <a class="header-anchor" href="#_3-将-asdf-data-dir-shims-加在-path-最前面" aria-label="Permalink to &quot;3. 将 `$ASDF_DATA_DIR/shims` 加在 `$PATH` 最前面&quot;">​</a></h4><p>在 shell RC 配置文件（与第 2 步相同的文件）中，将 <code>$ASDF_DATA_DIR/shims</code> 添加到路劲的开头：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ASDF_DATA_DIR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/home/myuser/.asdf&quot;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PATH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ASDF_DATA_DIR</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/shims:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$PATH</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span></code></pre></div><h4 id="_4-移除旧的配置文件" tabindex="-1">4. 移除旧的配置文件 <a class="header-anchor" href="#_4-移除旧的配置文件" aria-label="Permalink to &quot;4. 移除旧的配置文件&quot;">​</a></h4><p>在 shell RC 配置中，你会有旧代码在启动时运行 asdf shell 脚本。它可能看起来像这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>. &quot;$HOME/.asdf/asdf.sh&quot;</span></span></code></pre></div><p>或者这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>. /opt/homebrew/opt/asdf/libexec/asdf.sh</span></span></code></pre></div><p>注释掉这些行或者完全删除它们。</p><p>如果你未使用 Zsh 或者 Bash，请查阅旧版的 <a href="https://asdf-vm.com/zh-hans/guide/getting-started-legacy.html#_3-%E5%AE%89%E8%A3%85-asdf" target="_blank" rel="noreferrer">快速入门</a> 获悉需要删除的代码片段。</p><h4 id="_5-重新生成垫片" tabindex="-1">5. 重新生成垫片 <a class="header-anchor" href="#_5-重新生成垫片" aria-label="Permalink to &quot;5. 重新生成垫片&quot;">​</a></h4><p>请通过运行 <code>asdf --help</code> 命令，确认当前 shell 会话中 <code>asdf</code> 命令的版本为 0.16.0 或更高版本。如果仍显示旧版本，你需要启动一个新的 shell 会话。</p><p>一旦确认 <code>asdf</code> 命令为新版本后，运行 <code>asdf reshim</code> 来重新生成所有的垫片。这是必要的，因为旧的垫片可能仍使用旧的 Bash 版本。</p><h3 id="测试" tabindex="-1">测试 <a class="header-anchor" href="#测试" aria-label="Permalink to &quot;测试&quot;">​</a></h3><p>如果你不确定升级到 0.16.0 是否会导致问题，那么可以按照上述“不丢失数据的升级”的描述，在现有版本的基础上安装 0.16.0 进行测试。如果升级到 0.16.0 或更高版本导致问题，你可以回退到旧版本。删除添加在 shell RC 配置文件中的行，并重新添加删除或注释掉的行即可。</p><h3 id="移除旧文件" tabindex="-1">移除旧文件 <a class="header-anchor" href="#移除旧文件" aria-label="Permalink to &quot;移除旧文件&quot;">​</a></h3><p><strong>仅在完成上述所有步骤并确认新的 asdf 安装正常运行后再执行此操作！</strong> 升级后，你可以从旧版基于 Bash 脚本的 asdf 版本中移除旧文件。数据目录（通常为 <code>~/.asdf/</code>）中的大多数文件均可删除。需要注意的是，此操作并非强制要求。保留旧版本 asdf 的文件不会造成任何问题。必须<strong>保留</strong>的目录仅有：</p><ul><li><code>downloads/</code></li><li><code>installs/</code></li><li><code>plugins/</code></li><li><code>shims/</code></li></ul><p>其余文件可以删除。这可以通过 <code>find</code> 命令一次性完成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>find ${ASDF_DATA_DIR:-$HOME/.asdf}/ -maxdepth 1 -mindepth 1 -not -name downloads -not -name plugins -not -name installs -not -name shims -exec rm -r {} \\;</span></span></code></pre></div><h2 id="重大变更" tabindex="-1">重大变更 <a class="header-anchor" href="#重大变更" aria-label="Permalink to &quot;重大变更&quot;">​</a></h2><h3 id="连字符连接的命令已被移除" tabindex="-1">连字符连接的命令已被移除 <a class="header-anchor" href="#连字符连接的命令已被移除" aria-label="Permalink to &quot;连字符连接的命令已被移除&quot;">​</a></h3><p>asdf 版本 0.15.0 及更早版本对某些命令支持带连字符和不带连字符。从版本 0.16.0 开始，仅支持不带连字符的版本。受影响的命令有：</p><ul><li><code>asdf list-all</code> -&gt; <code>asdf list all</code></li><li><code>asdf plugin-add</code> -&gt; <code>asdf plugin add</code></li><li><code>asdf plugin-list</code> -&gt; <code>asdf plugin list</code></li><li><code>asdf plugin-list-all</code> -&gt; <code>asdf plugin list all</code></li><li><code>asdf plugin-update</code> -&gt; <code>asdf plugin update</code></li><li><code>asdf plugin-remove</code> -&gt; <code>asdf plugin remove</code></li><li><code>asdf plugin-test</code> -&gt; <code>asdf plugin test</code></li><li><code>asdf shim-versions</code> -&gt; <code>asdf shimversions</code></li></ul><h3 id="asdf-global-和-asdf-local-命令已被-asdf-set-取代" tabindex="-1"><code>asdf global</code> 和 <code>asdf local</code> 命令已被 <code>asdf set</code> 取代 <a class="header-anchor" href="#asdf-global-和-asdf-local-命令已被-asdf-set-取代" aria-label="Permalink to &quot;`asdf global` 和 `asdf local` 命令已被 `asdf set` 取代&quot;">​</a></h3><p><code>asdf global</code> 和 <code>asdf local</code> 已被移除。&quot;global&quot; 和 &quot;local&quot; 这一术语存在错误且容易引起误解。asdf 实际上并不支持适用于所有位置的 &quot;global&quot; 版本。任何通过 <code>asdf global</code> 指定的版本都可能被当前目录中的 <code>.tool-versions</code> 文件中指定的不同版本覆盖。这会让用户感到困惑。新的 <code>asdf set</code> 默认行为与 <code>asdf local</code> 相同，但还提供了用于在用户主目录（<code>--home</code>）和父目录中的现有 <code>.tool-versions</code> 文件（<code>--parent</code>）中设置版本的标志。这个新接口有望更好地传达 asdf 如何解析版本，并提供等效的功能。</p><h3 id="asdf-update-命令已被移除" tabindex="-1"><code>asdf update</code> 命令已被移除 <a class="header-anchor" href="#asdf-update-命令已被移除" aria-label="Permalink to &quot;`asdf update` 命令已被移除&quot;">​</a></h3><p>更新不再支持此方式。请使用操作系统包管理器或手动下载最新二进制文件。此外，版本 0.15.0 及更早版本中存在的 <code>asdf update</code> 命令无法升级到 0.16.0 版本，因为安装流程已经发生了改变。<strong>无法通过 <code>asdf update</code> 命令升级到最新 Go 实现版本。</strong></p><h3 id="asdf-shell-命令已被移除" tabindex="-1"><code>asdf shell</code> 命令已被移除 <a class="header-anchor" href="#asdf-shell-命令已被移除" aria-label="Permalink to &quot;`asdf shell` 命令已被移除&quot;">​</a></h3><p>该命令实际上在用户的当前 shell 会话中设置了一个环境变量。它能够做到这一点是因为 <code>asdf</code> 实际上是一个 shell 函数，而不是可执行文件。新的重写版本移除了 asdf 中的所有 shell 代码，现在它是一个二进制文件而非 shell 函数，因此直接在 shell 中设置环境变量已不再可能。</p><h3 id="asdf-current-已发生改变" tabindex="-1"><code>asdf current</code> 已发生改变 <a class="header-anchor" href="#asdf-current-已发生改变" aria-label="Permalink to &quot;`asdf current` 已发生改变&quot;">​</a></h3><p>输出中不再显示三列，最后一列不再显示版本设置的位置或建议用于设置或安装的命令。第三列已拆分成两列。现在的第三列仅指示版本的来源（如果已设置，通常为版本文件或环境变量），而第四列是布尔值，表示指定的版本是否实际已安装。如果未安装，将显示建议的安装命令。</p><h3 id="插件扩展命令现在必须以-cmd-为前缀" tabindex="-1">插件扩展命令现在必须以 <code>cmd</code> 为前缀 <a class="header-anchor" href="#插件扩展命令现在必须以-cmd-为前缀" aria-label="Permalink to &quot;插件扩展命令现在必须以 `cmd` 为前缀&quot;">​</a></h3><p>之前的插件扩展命令可以像这样运行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>asdf nodejs nodebuild --version</span></span></code></pre></div><p>现在它们必须以 <code>cmd</code> 为前缀，以避免与内置命令混淆：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>asdf cmd nodejs nodebuild --version</span></span></code></pre></div><h3 id="扩展命令已重新设计" tabindex="-1">扩展命令已重新设计 <a class="header-anchor" href="#扩展命令已重新设计" aria-label="Permalink to &quot;扩展命令已重新设计&quot;">​</a></h3><p>插件扩展命令有一系列的重大变更：</p><ul><li>它们必须可以通过 <code>exec</code> 系统调用运行。若扩展命令是 shell 脚本，为了能通过 <code>exec</code> 运行，它们必须以正确的 shebang（ <code>#!</code>）行开头。</li><li>它们现在可以是任何语言的二进制文件或脚本。不再要求使用 <code>.bash</code> 扩展名，因为这会引起误解。</li><li>它们必须具有可执行权限。</li><li>当缺少可执行权限时，它们不再被 asdf 作为 Bash 脚本加载。</li></ul><p>此外，仅使用插件名称后的第一个参数来确定要运行的扩展命令。这意味着实际上存在一个默认的 <code>command</code> 扩展命令，当未找到与插件名称后第一个参数匹配的命令时，asdf 会默认使用该命令。例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>foo/</span></span>\n<span class="line"><span>  lib/commands/</span></span>\n<span class="line"><span>    command</span></span>\n<span class="line"><span>    command-bar</span></span>\n<span class="line"><span>    command-bat-man</span></span></code></pre></div><p>先前这些脚本的工作方式是这样的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ asdf cmd foo         # 等同于运行 `$ASDF_DATA_DIR/plugins/foo/lib/commands/command`</span></span>\n<span class="line"><span>$ asdf cmd foo bar     # 等同于运行 `$ASDF_DATA_DIR/plugins/foo/lib/commands/command-bar`</span></span>\n<span class="line"><span>$ asdf cmd foo bat man # 等同于运行 `$ASDF_DATA_DIR/plugins/foo/lib/commands/command-bat-man`</span></span></code></pre></div><p>现在：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ asdf cmd foo         # 等同于运行 `$ASDF_DATA_DIR/plugins/foo/lib/commands/command`</span></span>\n<span class="line"><span>$ asdf cmd foo bar     # 等同于运行 `$ASDF_DATA_DIR/plugins/foo/lib/commands/command-bar`</span></span>\n<span class="line"><span>$ asdf cmd foo bat man # 等同于运行 `$ASDF_DATA_DIR/plugins/foo/lib/commands/command-bat man`</span></span></code></pre></div><h3 id="可执行文件的兼容性问题由-syscall-exec-解决" tabindex="-1">可执行文件的兼容性问题由 <code>syscall.Exec</code> 解决 <a class="header-anchor" href="#可执行文件的兼容性问题由-syscall-exec-解决" aria-label="Permalink to &quot;可执行文件的兼容性问题由 `syscall.Exec` 解决&quot;">​</a></h3><p>最明显的例子是缺少正确 shebang 行的脚本。asdf 0.15.0 及更早版本使用 Bash 实现，因此只要该可执行文件可通过 Bash 执行，即可运行。这意味着缺少 shebang 行的脚本仍可通过 <code>asdf exec</code> 运行。随着 asdf 0.16.x 改用 Go 语言实现，我们现在通过 Go 的 <code>syscall.Exec</code> 函数调用可执行文件，而该函数无法处理缺少 shebang 行的脚本。</p><p>实际上这并不是什么大问题。大多数 shell 脚本确实包含 shebang 行。如果由 asdf 管理且缺少 shebang 行，则需要手动添加。</p><h3 id="不再支持自定义垫片模版" tabindex="-1">不再支持自定义垫片模版 <a class="header-anchor" href="#不再支持自定义垫片模版" aria-label="Permalink to &quot;不再支持自定义垫片模版&quot;">​</a></h3><p>这是一个鲜少使用的功能。核心团队维护的唯一使用该功能的插件是 Elixir 插件，而该插件现已不再需要此功能。该功能最初添加的目的是，使由程序评估而非执行的垫片包含适合特定程序评估的代码（在 Elixir 的情况下，这是 <code>iex</code> shell。）经过进一步调查，似乎该功能仅存在于 <code>PATH</code> 环境变量中可执行文件路径有时被错误地设置为包含<strong>垫片</strong>文件而非其他<strong>可执行文件</strong>的情况，且该设置针对选定的版本。</p>',67)]))}const g=s(i,[["render",l]]);export{u as __pageData,g as default};
